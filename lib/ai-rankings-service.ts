import type { RankingSystem, PlayerRanking } from "./rankings-types";
import type { NFLDataResponse } from "./nfl-data-service";

export class AIRankingsService {
  private nflData: NFLDataResponse | null = null;

  async generateAIRankings(
    allRankings: RankingSystem[], 
    options?: { 
      year?: number; 
      week?: number; 
      useHistoricalData?: boolean;
    }
  ): Promise<RankingSystem> {
    // Fetch NFL historical data if requested
    if (options?.useHistoricalData !== false) {
      await this.fetchNFLHistoricalData(options?.year, options?.week);
    }

    const prompt = this.buildPromptWithHistoricalData(allRankings, options);

    // In a real implementation, you would send this prompt to a large language model.
    // For now, we will simulate the response with historical data context.
    const aiResponse = this.simulateAIResponseWithHistoricalData(allRankings, options);

    const aiRankings = this.parseAIResponse(aiResponse, options?.week);

    const seasonDesc = options?.year ? ` (${options.year}${options.week ? ` Week ${options.week}` : ''})` : '';
    const dataDesc = this.nflData ? ` with historical NFL data` : '';
    const projectionType = options?.week ? 'Weekly' : 'Season';

    return {
      id: "ai-generated",
      name: `AI ${projectionType} Rankings${seasonDesc}`,
      description: `${projectionType} rankings generated by analyzing all available data sources${dataDesc}.`,
      source: "AI",
      season: options?.year?.toString() || "2025",
      scoringFormat: "ppr",
      positions: ["all"],
      rankings: aiRankings,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      lastUpdated: new Date().toISOString(),
    };
  }

  private async fetchNFLHistoricalData(year?: number, week?: number): Promise<void> {
    try {
      console.log(`Fetching comprehensive NFL historical data for predictive analysis...`);
      
      // Always use 2024 data for predictions (most recent complete season)
      const currentYear = new Date().getFullYear();
      const targetYear = year || (currentYear >= 2025 ? 2025 : currentYear); // Default to next season
      const dataYear = 2024; // Always use 2024 data for historical analysis
      
      const params = new URLSearchParams({
        action: 'extract',
        years: dataYear.toString(),
        positions: 'QB,RB,WR,TE'
      });

      // For predictions, we don't filter by week - we want full historical data
      console.log(`Fetching ${dataYear} NFL data to predict ${targetYear}${week ? ` Week ${week}` : ''}`);

      const response = await fetch(`/api/nfl-data?${params}`);
      
      if (response.ok) {
        this.nflData = await response.json();
        console.log(`Successfully loaded comprehensive NFL data with ${this.nflData?.metadata.total_players || 0} players and ${this.nflData?.metadata.total_aggregated_records || 0} season records for predictive analysis`);
      } else {
        console.warn('Failed to fetch NFL historical data for rankings');
        this.nflData = null;
      }
    } catch (error) {
      console.error('Error fetching NFL historical data:', error);
      this.nflData = null;
    }
  }

  private buildPrompt(allRankings: RankingSystem[]): string {
    let prompt = "Analyze the following player rankings from different sources and create a single, consolidated ranking. Justify your rankings with a brief analysis for each player.\n\n";

    for (const system of allRankings) {
      prompt += `Source: ${system.name}\n`;
      prompt += "--------------------\n";
      for (const ranking of system.rankings.slice(0, 20)) { // Limit to top 20 for brevity
        prompt += `${ranking.rank}. ${ranking.playerName} (${ranking.position} - ${ranking.team})\n`;
      }
      prompt += "\n";
    }

    return prompt;
  }

  private buildPromptWithHistoricalData(
    allRankings: RankingSystem[], 
    options?: { year?: number; week?: number; useHistoricalData?: boolean }
  ): string {
    let prompt = "Analyze the following player rankings from different sources and create a single, consolidated ranking. ";
    prompt += "Use the provided historical NFL performance data as additional context to make more informed predictions.\n\n";

    // Add historical data context if available
    if (this.nflData) {
      prompt += "HISTORICAL NFL PERFORMANCE DATA:\n";
      prompt += "================================\n";
      
      const year = options?.year || 2024;
      const week = options?.week;
      
      if (week) {
        prompt += `Week ${week}, ${year} Performance:\n`;
      } else {
        prompt += `${year} Season Performance:\n`;
      }
      
      // Add top performers by position from historical data
      this.addHistoricalPerformanceContext(prompt, week ? 'weekly' : 'season');
      
      prompt += "\n";
    }

    // Add user rankings
    if (allRankings.length > 0) {
      prompt += "USER PROVIDED RANKINGS:\n";
      prompt += "======================\n";
      
      for (const system of allRankings) {
        prompt += `Source: ${system.name}\n`;
        prompt += "--------------------\n";
        for (const ranking of system.rankings.slice(0, 20)) {
          prompt += `${ranking.rank}. ${ranking.playerName} (${ranking.position} - ${ranking.team})\n`;
        }
        prompt += "\n";
      }
    }

    prompt += "\nInstructions: Create consolidated rankings that balance user preferences with historical performance data. ";
    prompt += "Prioritize players with strong historical performance while respecting user ranking systems. ";
    prompt += "Consider recent trends, consistency, and upside potential.\n";

    return prompt;
  }

  private addHistoricalPerformanceContext(prompt: string, type: 'weekly' | 'season'): void {
    if (!this.nflData) return;

    const data = type === 'weekly' ? this.nflData.weekly_stats : this.nflData.aggregated_season_stats;
    
    prompt += `\nCOMPREHENSIVE HISTORICAL PERFORMANCE ANALYSIS:\n`;
    prompt += `Data includes ${this.nflData.metadata.total_players} players across ${this.nflData.metadata.years.join(', ')}\n`;
    prompt += `Total season records: ${this.nflData.metadata.total_aggregated_records}\n`;
    prompt += `\nUse the following metrics for predictive analysis:\n`;
    
    // Group by position and get comprehensive stats for top performers
    const positions = ['QB', 'RB', 'WR', 'TE'];
    
    for (const pos of positions) {
      const positionPlayers = data
        .filter(player => player.position === pos)
        .sort((a, b) => (b.fantasy_points_ppr || 0) - (a.fantasy_points_ppr || 0))
        .slice(0, 12); // More players for better predictive context

      if (positionPlayers.length > 0) {
        prompt += `\n${pos} PERFORMANCE METRICS:\n`;
        prompt += `${'='.repeat(pos.length + 20)}\n`;
        
        positionPlayers.forEach((player, index) => {
          prompt += `${index + 1}. ${player.player_name} (${player.team}):\n`;
          
          // Fantasy Metrics
          const ppr = player.fantasy_points_ppr?.toFixed(1) || '0.0';
          const std = player.fantasy_points?.toFixed(1) || '0.0';
          const games = player.games || 0;
          const pprPerGame = games > 0 ? (player.fantasy_points_ppr || 0) / games : 0;
          
          prompt += `   Fantasy: ${ppr} PPR (${std} STD) | ${pprPerGame.toFixed(1)} PPR/game | ${games} games\n`;
          
          // Position-specific metrics
          if (pos === 'QB') {
            prompt += `   Passing: ${player.passing_yards || 0} yds, ${player.passing_tds || 0} TDs, ${player.interceptions || 0} INTs\n`;
            prompt += `   Efficiency: ${((player.completions || 0) / (player.passing_attempts || 1) * 100).toFixed(1)}% comp, ${((player.passing_yards || 0) / (player.passing_attempts || 1)).toFixed(1)} Y/A\n`;
            if (player.rushing_yards) {
              prompt += `   Rushing: ${player.rushing_yards} yds, ${player.rushing_tds || 0} TDs\n`;
            }
          } else if (pos === 'RB') {
            prompt += `   Rushing: ${player.rushing_yards || 0} yds, ${player.rushing_tds || 0} TDs, ${player.rushing_attempts || 0} att\n`;
            prompt += `   Efficiency: ${((player.rushing_yards || 0) / (player.rushing_attempts || 1)).toFixed(1)} YPC\n`;
            if (player.targets) {
              prompt += `   Receiving: ${player.receptions || 0}/${player.targets} tgt, ${player.receiving_yards || 0} yds, ${player.receiving_tds || 0} TDs\n`;
            }
          } else if (pos === 'WR' || pos === 'TE') {
            prompt += `   Receiving: ${player.receptions || 0}/${player.targets || 0} tgt, ${player.receiving_yards || 0} yds, ${player.receiving_tds || 0} TDs\n`;
            prompt += `   Efficiency: ${player.targets ? ((player.receptions || 0) / player.targets * 100).toFixed(1) : '0.0'}% catch rate, ${player.targets ? ((player.receiving_yards || 0) / player.targets).toFixed(1) : '0.0'} Y/T\n`;
            if (player.target_share) {
              prompt += `   Usage: ${(player.target_share * 100).toFixed(1)}% target share\n`;
            }
          }
          
          // Advanced metrics
          if (player.red_zone_targets || player.red_zone_carries || player.red_zone_touches) {
            const rzTargets = player.red_zone_targets || 0;
            const rzCarries = player.red_zone_carries || 0;
            const rzTouches = player.red_zone_touches || 0;
            prompt += `   Red Zone: ${rzTargets} tgt, ${rzCarries} car, ${rzTouches} touches\n`;
          }
          
          prompt += `\n`;
        });
      }
    }

    // Add trend analysis
    prompt += `\nTREND ANALYSIS GUIDELINES:\n`;
    prompt += `- Prioritize players with consistent high performance across multiple seasons\n`;
    prompt += `- Consider efficiency metrics (YPC, catch rate, target share) for upside\n`;
    prompt += `- Weight red zone usage heavily for TD prediction\n`;
    prompt += `- Factor in team context and offensive systems\n`;
    prompt += `- Account for age and injury history when available\n\n`;
  }

  private simulateAIResponse(allRankings: RankingSystem[]): string {
    // This is a simplified simulation. A real AI would provide much more nuanced analysis.
    const allPlayers = allRankings.flatMap(system => system.rankings);
    const uniquePlayers = Array.from(new Set(allPlayers.map(p => p.playerName))).map(name => {
      return allPlayers.find(p => p.playerName === name)!;
    });

    let response = "";
    uniquePlayers.slice(0, 50).forEach((player, index) => {
      response += `${index + 1}. ${player.playerName} - Analysis: Consolidated top player based on average ranking across sources.\n`;
    });

    return response;
  }

  private simulateAIResponseWithHistoricalData(allRankings: RankingSystem[], options?: { year?: number; week?: number }): string {
    // Enhanced predictive simulation using comprehensive historical data and user rankings
    let response = "";
    let playerRankings: Array<{
      name: string;
      position: string;
      team: string;
      userRank?: number;
      userConsensusRank?: number;
      userProjectedPoints?: number;
      sourceCount: number;
      predictiveScore: number;
      projectedPoints: number;
      tier: number;
      analysis: string;
    }> = [];

    // Get all available historical data for predictive modeling
    if (!this.nflData?.aggregated_season_stats || this.nflData.aggregated_season_stats.length === 0) {
      console.warn('No NFL historical data available, creating fallback rankings based on user data or defaults');
      
      // If user rankings exist, use them as a base for AI analysis
      const allPlayers = allRankings.flatMap(system => system.rankings);
      if (allPlayers.length > 0) {
        response += "AI ANALYSIS (Based on User Rankings Only):\\n";
        response += "No historical NFL data available, but analyzing your provided rankings.\\n\\n";
        
        const uniquePlayers = Array.from(new Set(allPlayers.map(p => p.playerName))).map(name => {
          const player = allPlayers.find(p => p.playerName === name)!;
          const avgRank = allPlayers.filter(p => p.playerName === name)
            .reduce((sum, p) => sum + p.rank, 0) / allPlayers.filter(p => p.playerName === name).length;
          return { ...player, avgRank };
        }).sort((a, b) => a.avgRank - b.avgRank);
        
        uniquePlayers.slice(0, 50).forEach((player, index) => {
          response += `${index + 1}. ${player.playerName} (${player.position} - ${player.team}) - Analysis: Strong user consensus ranking (avg #${Math.round(player.avgRank)}), recommended based on expert sources.\\n`;
        });
        
        return response;
      }
      
      // Create default top fantasy players for 2025 if no data is available
      response += "PREDICTIVE RANKINGS FOR UPCOMING SEASON:\\n";
      response += "No historical data available, using default top fantasy players as baseline.\\n\\n";
      
      const defaultPlayers = [
        { name: "Josh Allen", position: "QB", team: "BUF", points: 24.5 },
        { name: "Lamar Jackson", position: "QB", team: "BAL", points: 23.8 },
        { name: "Christian McCaffrey", position: "RB", team: "SF", points: 22.1 },
        { name: "Bijan Robinson", position: "RB", team: "ATL", points: 18.9 },
        { name: "Justin Jefferson", position: "WR", team: "MIN", points: 17.8 },
        { name: "CeeDee Lamb", position: "WR", team: "DAL", points: 17.2 },
        { name: "Tyreek Hill", position: "WR", team: "MIA", points: 16.9 },
        { name: "Travis Kelce", position: "TE", team: "KC", points: 15.7 },
        { name: "Saquon Barkley", position: "RB", team: "PHI", points: 19.2 },
        { name: "Ja'Marr Chase", position: "WR", team: "CIN", points: 16.4 }
      ];
      
      defaultPlayers.forEach((player, index) => {
        response += `${index + 1}. ${player.name} (${player.position} - ${player.team}) - Analysis: Elite fantasy option with ${player.points} PPR/game projection. Strong baseline player for upcoming season.\\n`;
      });
      
      return response;
    }

    // Build comprehensive player database with predictive scores
    const historicalPlayers = this.nflData.aggregated_season_stats.map(player => {
      const predictiveScore = this.calculatePredictiveScore(player);
      const projectedPoints = this.projectPoints(player, options?.week);
      const tier = this.calculateTier(player.position || 'N/A', projectedPoints, options?.week);
      
      return {
        name: player.player_name || 'Unknown',
        position: player.position || 'N/A',
        team: player.team || 'N/A',
        predictiveScore,
        projectedPoints,
        tier,
        analysis: this.generatePredictiveAnalysis(player)
      };
    });

    // Enhanced user ranking analysis and integration
    const allPlayers = allRankings.flatMap(system => system.rankings);
    
    if (allPlayers.length > 0) {
      console.log(`Analyzing ${allPlayers.length} user rankings from ${allRankings.length} sources for AI enhancement`);
      
      // Create comprehensive user consensus analysis
      const userPlayerAnalysis = this.analyzeUserRankings(allPlayers);
      
      // Blend user rankings with historical data
      const uniqueUserPlayers = Array.from(userPlayerAnalysis.values()).map(userAnalysis => {
        // Find historical data for this user-ranked player using improved matching
        const historicalData = this.findBestHistoricalMatch(userAnalysis.playerName, historicalPlayers);
        
        if (historicalData) {
          // Calculate enhanced predictive score incorporating user consensus
          const userBoost = this.calculateUserConsensusBoost(userAnalysis);
          const enhancedScore = historicalData.predictiveScore + userBoost;
          
          // Enhanced analysis with user data integration
          const enhancedAnalysis = this.generateEnhancedAnalysis(historicalData, userAnalysis, options?.week);
          
          return {
            ...historicalData,
            userRank: userAnalysis.averageRank,
            userConsensusRank: userAnalysis.consensusRank,
            userProjectedPoints: userAnalysis.averageProjectedPoints,
            sourceCount: userAnalysis.sourceCount,
            predictiveScore: enhancedScore,
            analysis: enhancedAnalysis
          };
        }
        
        // If no historical match, create entry based purely on user consensus
        return this.createUserBasedRanking(userAnalysis, options?.week);
      }).filter(Boolean);

      // Combine user-enhanced and pure historical players
      const allRankedPlayers = new Map();
      
      // Add all historical players first
      historicalPlayers.forEach(player => {
        allRankedPlayers.set(player.name.toLowerCase(), player);
      });
      
      // Override with user-enhanced players
      uniqueUserPlayers.forEach(player => {
        if (player) {
          allRankedPlayers.set(player.name.toLowerCase(), player);
        }
      });

      playerRankings = Array.from(allRankedPlayers.values());
    } else {
      // No user rankings - use pure historical data predictions
      playerRankings = historicalPlayers;
    }

    // Sort by predictive score
    playerRankings.sort((a, b) => b.predictiveScore - a.predictiveScore);

    // Generate top 50 predictions
    const projectionType = options?.week ? `Week ${options.week}` : 'Season';
    response += `PREDICTIVE RANKINGS FOR UPCOMING ${projectionType.toUpperCase()}:\n`;
    response += `Based on comprehensive historical analysis including fantasy points, efficiency metrics, usage patterns, and trend analysis.\n`;
    
    if (options?.week) {
      response += `Note: Projected points are for single-game (weekly) performance.\n\n`;
    } else {
      response += `Note: Projected points are for full season (17-game) performance.\n\n`;
    }
    
    playerRankings.slice(0, 50).forEach((player, index) => {
      response += `${index + 1}. ${player.name} (${player.position} - ${player.team}) - Analysis: ${player.analysis}\n`;
    });

    return response;
  }

  private calculatePredictiveScore(player: any): number {
    let score = 0;
    
    // Base fantasy production (40% of score)
    const pprPoints = player.fantasy_points_ppr || 0;
    const games = player.games || 1;
    const pprPerGame = pprPoints / games;
    score += (pprPerGame * 4); // Scale to meaningful range
    
    // Efficiency metrics (30% of score)
    if (player.position === 'QB') {
      const compRate = (player.completions || 0) / (player.passing_attempts || 1);
      const passingEPA = player.passing_epa || 0;
      score += (compRate * 100) + (passingEPA * 5);
    } else if (player.position === 'RB') {
      const ypc = (player.rushing_yards || 0) / (player.rushing_attempts || 1);
      const catchRate = player.targets ? (player.receptions || 0) / player.targets : 0;
      score += (ypc * 20) + (catchRate * 50);
    } else if (player.position === 'WR' || player.position === 'TE') {
      const catchRate = player.targets ? (player.receptions || 0) / player.targets : 0;
      const yardsPerTarget = player.targets ? (player.receiving_yards || 0) / player.targets : 0;
      const targetShare = player.target_share || 0;
      score += (catchRate * 100) + (yardsPerTarget * 5) + (targetShare * 200);
    }
    
    // Usage and opportunity (20% of score)
    const rzOpportunities = (player.red_zone_targets || 0) + (player.red_zone_carries || 0);
    score += rzOpportunities * 2;
    
    // Consistency factor (10% of score)
    if (games >= 12) score += 10; // Durability bonus
    if (games >= 16) score += 5;  // Full season bonus
    
    return Math.max(0, score);
  }

  private projectPoints(player: any, week?: number): number {
    const currentPPR = player.fantasy_points_ppr || 0;
    const games = player.games || 16;
    const perGameRate = currentPPR / games;
    
    // Project per-game rate with regression/progression factors
    let projectedPerGame = perGameRate;
    
    // Age/experience adjustments (if we had age data)
    // Young players with high efficiency get slight boost
    if (player.position === 'RB' && (player.yards_per_carry || 0) > 4.5) {
      projectedPerGame *= 1.05; // 5% boost for efficient young RBs
    }
    
    // High target share players maintain production
    if ((player.position === 'WR' || player.position === 'TE') && (player.target_share || 0) > 0.2) {
      projectedPerGame *= 1.03; // 3% boost for high target share
    }
    
    // Return weekly or seasonal projection based on context
    if (week) {
      // For weekly projections, return per-game rate
      return projectedPerGame;
    } else {
      // For seasonal projections, multiply by 17 games
      return projectedPerGame * 17;
    }
  }

  private calculateTier(position: string, projectedPoints: number, week?: number): number {
    // Different tier breakpoints for weekly vs seasonal projections
    const seasonalTierBreakpoints = {
      'QB': [300, 280, 260, 240, 220],
      'RB': [280, 250, 220, 190, 160],
      'WR': [250, 220, 190, 160, 130],
      'TE': [180, 150, 120, 100, 80]
    };
    
    const weeklyTierBreakpoints = {
      'QB': [20, 18, 16, 14, 12],
      'RB': [18, 16, 14, 12, 10],
      'WR': [16, 14, 12, 10, 8],
      'TE': [12, 10, 8, 6, 4]
    };
    
    const breakpoints = week 
      ? (weeklyTierBreakpoints[position] || weeklyTierBreakpoints['WR'])
      : (seasonalTierBreakpoints[position] || seasonalTierBreakpoints['WR']);
    
    for (let i = 0; i < breakpoints.length; i++) {
      if (projectedPoints >= breakpoints[i]) {
        return i + 1;
      }
    }
    
    return 6; // Tier 6 for lower projections
  }

  private generatePredictiveAnalysis(player: any): string {
    const ppr = player.fantasy_points_ppr || 0;
    const games = player.games || 0;
    const pprPerGame = games > 0 ? ppr / games : 0;
    
    let analysis = `${pprPerGame.toFixed(1)} PPR/game across ${games} games. `;
    
    if (player.position === 'QB') {
      const passingYards = player.passing_yards || 0;
      const passingTDs = player.passing_tds || 0;
      const rushingYards = player.rushing_yards || 0;
      analysis += `${passingYards} pass yds, ${passingTDs} pass TDs`;
      if (rushingYards > 200) analysis += `, ${rushingYards} rush yds (dual-threat upside)`;
    } else if (player.position === 'RB') {
      const rushingYards = player.rushing_yards || 0;
      const targets = player.targets || 0;
      const ypc = (player.rushing_attempts || 0) > 0 ? rushingYards / player.rushing_attempts : 0;
      analysis += `${rushingYards} rush yds (${ypc.toFixed(1)} YPC)`;
      if (targets > 30) analysis += `, ${targets} targets (pass-catching value)`;
    } else if (player.position === 'WR' || player.position === 'TE') {
      const targets = player.targets || 0;
      const catchRate = targets > 0 ? (player.receptions || 0) / targets * 100 : 0;
      const targetShare = (player.target_share || 0) * 100;
      analysis += `${targets} targets, ${catchRate.toFixed(1)}% catch rate`;
      if (targetShare > 15) analysis += `, ${targetShare.toFixed(1)}% target share (high usage)`;
    }
    
    // Add red zone context
    const rzOpps = (player.red_zone_targets || 0) + (player.red_zone_carries || 0);
    if (rzOpps > 10) {
      analysis += `. Strong red zone usage (${rzOpps} opportunities)`;
    }
    
    return analysis + ".";
  }

  private parseAIResponse(aiResponse: string, week?: number): PlayerRanking[] {
    const rankings: PlayerRanking[] = [];
    const lines = aiResponse.split("\n");

    for (const line of lines) {
      // Updated regex to handle the enhanced format with position and team
      const match = line.match(/(\d+)\. (.*?) \((.*?) - (.*?)\) - Analysis: (.*)/);
      if (match) {
        const [, rank, playerName, position, team, analysis] = match;
        
        // Extract projected points from analysis if available
        const projectedPointsMatch = analysis.match(/(\d+\.?\d*) PPR\/game/);
        let projectedPoints = undefined;
        if (projectedPointsMatch) {
          const pointsPerGame = parseFloat(projectedPointsMatch[1]);
          // For weekly projections, use per-game rate; for season, multiply by 17
          projectedPoints = week ? pointsPerGame : pointsPerGame * 17;
        }
        
        // Calculate tier based on position and projected points
        let tier = undefined;
        if (projectedPoints) {
          tier = this.calculateTier(position, projectedPoints, week);
        }
        
        rankings.push({
          rank: parseInt(rank),
          playerId: `ai-${playerName.toLowerCase().replace(/\s/g, "-")}-${position.toLowerCase()}-${team.toLowerCase()}-${parseInt(rank)}`,
          playerName,
          position,
          team,
          projectedPoints,
          tier,
          notes: analysis,
        });
      } else {
        // Fallback to original format for backward compatibility
        const fallbackMatch = line.match(/(\d+)\. (.*?) - Analysis: (.*)/);
        if (fallbackMatch) {
          const [, rank, playerName, analysis] = fallbackMatch;
          rankings.push({
            rank: parseInt(rank),
            playerId: `ai-${playerName.toLowerCase().replace(/\s/g, "-")}-fallback-${parseInt(rank)}`,
            playerName,
            position: "N/A",
            team: "N/A", 
            notes: analysis,
          });
        }
      }
    }

    return rankings;
  }

  // Helper method to get historical player data for a specific player
  private getHistoricalPlayerData(playerName: string): any {
    if (!this.nflData) return null;

    const normalizedName = playerName.toLowerCase();
    
    // Search in aggregated season stats first
    const seasonData = this.nflData.aggregated_season_stats.find(player => 
      player.player_name?.toLowerCase().includes(normalizedName) ||
      normalizedName.includes(player.player_name?.toLowerCase() || '')
    );

    if (seasonData) return seasonData;

    // Search in weekly stats as fallback
    const weeklyData = this.nflData.weekly_stats.find(player => 
      player.player_name?.toLowerCase().includes(normalizedName) ||
      normalizedName.includes(player.player_name?.toLowerCase() || '')
    );

    return weeklyData;
  }

  // Analyze user rankings to create consensus data
  private analyzeUserRankings(allPlayers: any[]): Map<string, any> {
    const playerAnalysis = new Map();
    
    // Group by player name (case-insensitive)
    allPlayers.forEach(player => {
      const normalizedName = player.playerName.toLowerCase().trim();
      
      if (!playerAnalysis.has(normalizedName)) {
        playerAnalysis.set(normalizedName, {
          playerName: player.playerName, // Keep original casing
          position: player.position,
          team: player.team,
          ranks: [],
          projectedPoints: [],
          sources: []
        });
      }
      
      const analysis = playerAnalysis.get(normalizedName);
      analysis.ranks.push(player.rank);
      analysis.sources.push(player);
      
      if (player.projectedPoints) {
        analysis.projectedPoints.push(player.projectedPoints);
      }
    });
    
    // Calculate consensus metrics for each player
    playerAnalysis.forEach((analysis, playerName) => {
      const ranks = analysis.ranks;
      const projections = analysis.projectedPoints;
      
      // Calculate various ranking metrics
      analysis.averageRank = ranks.reduce((sum, rank) => sum + rank, 0) / ranks.length;
      analysis.medianRank = this.calculateMedian(ranks);
      analysis.minRank = Math.min(...ranks);
      analysis.maxRank = Math.max(...ranks);
      analysis.rankStdDev = this.calculateStandardDeviation(ranks);
      analysis.sourceCount = ranks.length;
      
      // Calculate consensus rank (weighted average favoring sources with similar ranks)
      analysis.consensusRank = this.calculateConsensusRank(ranks);
      
      // Calculate projection consensus
      if (projections.length > 0) {
        analysis.averageProjectedPoints = projections.reduce((sum, pts) => sum + pts, 0) / projections.length;
        analysis.projectionStdDev = this.calculateStandardDeviation(projections);
      }
      
      // Calculate confidence score based on agreement between sources
      analysis.confidenceScore = this.calculateConfidenceScore(ranks, projections);
    });
    
    return playerAnalysis;
  }

  // Improved player matching between user rankings and historical data
  private findBestHistoricalMatch(playerName: string, historicalPlayers: any[]): any {
    const normalizedName = playerName.toLowerCase().trim();
    
    // Try exact name match first
    let match = historicalPlayers.find(hp => 
      hp.name.toLowerCase().trim() === normalizedName
    );
    
    if (match) return match;
    
    // Try partial name matching with similarity scoring
    let bestMatch = null;
    let bestScore = 0;
    
    historicalPlayers.forEach(hp => {
      const historicalName = hp.name.toLowerCase().trim();
      const similarity = this.calculateNameSimilarity(normalizedName, historicalName);
      
      if (similarity > bestScore && similarity > 0.6) { // Minimum 60% similarity
        bestScore = similarity;
        bestMatch = hp;
      }
    });
    
    return bestMatch;
  }

  // Calculate user consensus boost to predictive score
  private calculateUserConsensusBoost(userAnalysis: any): number {
    let boost = 0;
    
    // Base boost based on consensus rank
    const consensusRank = userAnalysis.consensusRank || userAnalysis.averageRank;
    if (consensusRank <= 5) {
      boost += 30; // Top 5 picks get significant boost
    } else if (consensusRank <= 12) {
      boost += 20; // Top 12 get good boost
    } else if (consensusRank <= 24) {
      boost += 15; // Top 24 get moderate boost
    } else if (consensusRank <= 50) {
      boost += 10; // Top 50 get small boost
    }
    
    // Additional boost for strong consensus (multiple sources agreeing)
    const sourceCount = userAnalysis.sourceCount;
    const confidenceScore = userAnalysis.confidenceScore || 0;
    
    if (sourceCount >= 3 && confidenceScore > 0.8) {
      boost += 15; // Strong consensus bonus
    } else if (sourceCount >= 2 && confidenceScore > 0.7) {
      boost += 10; // Good consensus bonus
    }
    
    // Projection-based boost
    if (userAnalysis.averageProjectedPoints) {
      const projectedPoints = userAnalysis.averageProjectedPoints;
      if (projectedPoints > 15) {
        boost += 10; // High projection bonus
      } else if (projectedPoints > 10) {
        boost += 5; // Moderate projection bonus
      }
    }
    
    return boost;
  }

  // Generate enhanced analysis combining historical and user data
  private generateEnhancedAnalysis(historicalData: any, userAnalysis: any, isWeekly?: number): string {
    let analysis = historicalData.analysis || "";
    
    // Add user consensus information
    const consensus = userAnalysis.consensusRank || userAnalysis.averageRank;
    const sourceCount = userAnalysis.sourceCount;
    
    analysis += ` Expert consensus: #${Math.round(consensus)} (${sourceCount} source${sourceCount > 1 ? 's' : ''})`;
    
    // Add confidence indicator
    const confidence = userAnalysis.confidenceScore || 0;
    if (confidence > 0.8) {
      analysis += ", strong agreement";
    } else if (confidence > 0.6) {
      analysis += ", moderate agreement";
    } else if (sourceCount > 1) {
      analysis += ", mixed opinions";
    }
    
    // Add projection information
    if (userAnalysis.averageProjectedPoints) {
      const projType = isWeekly ? "weekly" : "season";
      analysis += `. Expert projections: ${userAnalysis.averageProjectedPoints.toFixed(1)} pts (${projType})`;
      
      if (userAnalysis.projectionStdDev && userAnalysis.projectionStdDev > 2) {
        analysis += ", projection variance noted";
      }
    }
    
    return analysis + ".";
  }

  // Create ranking entry based purely on user consensus (for players without historical data)
  private createUserBasedRanking(userAnalysis: any, isWeekly?: number): any {
    const consensus = userAnalysis.consensusRank || userAnalysis.averageRank;
    const baseScore = Math.max(100 - consensus, 10); // Base score inversely related to rank
    
    // Enhanced score for strong consensus
    const confidenceBoost = (userAnalysis.confidenceScore || 0) * 20;
    const sourceBoost = Math.min(userAnalysis.sourceCount * 5, 25);
    
    const predictiveScore = baseScore + confidenceBoost + sourceBoost;
    
    // Use user projected points or estimate based on position and rank
    let projectedPoints = userAnalysis.averageProjectedPoints;
    if (!projectedPoints) {
      const positionBaseline = {
        'QB': 18, 'RB': 12, 'WR': 10, 'TE': 8
      }[userAnalysis.position] || 8;
      
      projectedPoints = Math.max(positionBaseline - (consensus * 0.3), 3);
      if (!isWeekly) {
        projectedPoints *= 17; // Convert to season total
      }
    }
    
    const tier = this.calculateTier(userAnalysis.position, projectedPoints, isWeekly);
    
    const analysis = `Expert-only ranking based on ${userAnalysis.sourceCount} source${userAnalysis.sourceCount > 1 ? 's' : ''}. ` +
      `Consensus rank: #${Math.round(consensus)}. Limited historical data available for comparison.`;
    
    return {
      name: userAnalysis.playerName,
      position: userAnalysis.position,
      team: userAnalysis.team,
      userRank: userAnalysis.averageRank,
      userConsensusRank: userAnalysis.consensusRank,
      userProjectedPoints: userAnalysis.averageProjectedPoints,
      sourceCount: userAnalysis.sourceCount,
      predictiveScore,
      projectedPoints,
      tier,
      analysis
    };
  }

  // Statistical helper methods
  private calculateMedian(numbers: number[]): number {
    const sorted = [...numbers].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
  }

  private calculateStandardDeviation(numbers: number[]): number {
    const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
    const variance = numbers.reduce((sum, num) => sum + Math.pow(num - mean, 2), 0) / numbers.length;
    return Math.sqrt(variance);
  }

  private calculateConsensusRank(ranks: number[]): number {
    // Weighted average that gives more weight to ranks that are closer together
    const sortedRanks = [...ranks].sort((a, b) => a - b);
    const median = this.calculateMedian(ranks);
    
    // Weight ranks based on distance from median (closer = higher weight)
    let weightedSum = 0;
    let totalWeight = 0;
    
    ranks.forEach(rank => {
      const distance = Math.abs(rank - median);
      const weight = 1 / (1 + distance * 0.1); // Inverse distance weighting
      weightedSum += rank * weight;
      totalWeight += weight;
    });
    
    return weightedSum / totalWeight;
  }

  private calculateConfidenceScore(ranks: number[], projections?: number[]): number {
    if (ranks.length < 2) return 1; // Perfect confidence for single source
    
    const rankStdDev = this.calculateStandardDeviation(ranks);
    const rankMean = ranks.reduce((sum, rank) => sum + rank, 0) / ranks.length;
    
    // Confidence based on rank agreement (lower std dev = higher confidence)
    let rankConfidence = Math.max(0, 1 - (rankStdDev / (rankMean * 0.5)));
    
    // Factor in projection agreement if available
    let projectionConfidence = 1;
    if (projections && projections.length > 1) {
      const projStdDev = this.calculateStandardDeviation(projections);
      const projMean = projections.reduce((sum, proj) => sum + proj, 0) / projections.length;
      projectionConfidence = Math.max(0, 1 - (projStdDev / (projMean * 0.3)));
    }
    
    // Combined confidence score
    return (rankConfidence + projectionConfidence) / 2;
  }

  private calculateNameSimilarity(name1: string, name2: string): number {
    // Simple similarity calculation based on common words and character overlap
    const words1 = name1.split(/\s+/);
    const words2 = name2.split(/\s+/);
    
    let commonWords = 0;
    words1.forEach(word1 => {
      if (words2.some(word2 => word2.includes(word1) || word1.includes(word2))) {
        commonWords++;
      }
    });
    
    const wordSimilarity = commonWords / Math.max(words1.length, words2.length);
    
    // Character-level similarity using simple overlap
    const chars1 = new Set(name1.replace(/\s/g, ''));
    const chars2 = new Set(name2.replace(/\s/g, ''));
    const commonChars = new Set([...chars1].filter(char => chars2.has(char)));
    const charSimilarity = commonChars.size / Math.max(chars1.size, chars2.size);
    
    // Weighted combination
    return wordSimilarity * 0.7 + charSimilarity * 0.3;
  }
}