import type { RankingSystem, PlayerRanking } from "./rankings-types";
import type { NFLDataResponse } from "./nfl-data-service";

export class AIRankingsService {
  private nflData: NFLDataResponse | null = null;

  async generateAIRankings(
    allRankings: RankingSystem[], 
    options?: { 
      year?: number; 
      week?: number; 
      useHistoricalData?: boolean;
    }
  ): Promise<RankingSystem> {
    // Fetch NFL historical data if requested
    if (options?.useHistoricalData !== false) {
      await this.fetchNFLHistoricalData(options?.year, options?.week);
    }

    const prompt = this.buildPromptWithHistoricalData(allRankings, options);

    // In a real implementation, you would send this prompt to a large language model.
    // For now, we will simulate the response with historical data context.
    const aiResponse = this.simulateAIResponseWithHistoricalData(allRankings);

    const aiRankings = this.parseAIResponse(aiResponse);

    const seasonDesc = options?.year ? ` (${options.year}${options.week ? ` Week ${options.week}` : ''})` : '';
    const dataDesc = this.nflData ? ` with historical NFL data` : '';

    return {
      id: "ai-generated",
      name: `AI Consolidated Rankings${seasonDesc}`,
      description: `Rankings generated by analyzing all available data sources${dataDesc}.`,
      source: "AI",
      season: options?.year?.toString() || "2025",
      scoringFormat: "ppr",
      positions: ["all"],
      rankings: aiRankings,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      lastUpdated: new Date().toISOString(),
    };
  }

  private async fetchNFLHistoricalData(year?: number, week?: number): Promise<void> {
    try {
      console.log(`Fetching NFL historical data for analysis...`);
      
      const params = new URLSearchParams({
        action: 'extract',
        years: (year || 2024).toString(),
        positions: 'QB,RB,WR,TE'
      });

      if (week) {
        params.set('week', week.toString());
      }

      const response = await fetch(`/api/nfl-data?${params}`);
      
      if (response.ok) {
        this.nflData = await response.json();
        console.log(`Successfully loaded NFL data with ${this.nflData?.metadata.total_players || 0} players for rankings analysis`);
      } else {
        console.warn('Failed to fetch NFL historical data for rankings');
        this.nflData = null;
      }
    } catch (error) {
      console.error('Error fetching NFL historical data:', error);
      this.nflData = null;
    }
  }

  private buildPrompt(allRankings: RankingSystem[]): string {
    let prompt = "Analyze the following player rankings from different sources and create a single, consolidated ranking. Justify your rankings with a brief analysis for each player.\n\n";

    for (const system of allRankings) {
      prompt += `Source: ${system.name}\n`;
      prompt += "--------------------\n";
      for (const ranking of system.rankings.slice(0, 20)) { // Limit to top 20 for brevity
        prompt += `${ranking.rank}. ${ranking.playerName} (${ranking.position} - ${ranking.team})\n`;
      }
      prompt += "\n";
    }

    return prompt;
  }

  private buildPromptWithHistoricalData(
    allRankings: RankingSystem[], 
    options?: { year?: number; week?: number; useHistoricalData?: boolean }
  ): string {
    let prompt = "Analyze the following player rankings from different sources and create a single, consolidated ranking. ";
    prompt += "Use the provided historical NFL performance data as additional context to make more informed predictions.\n\n";

    // Add historical data context if available
    if (this.nflData) {
      prompt += "HISTORICAL NFL PERFORMANCE DATA:\n";
      prompt += "================================\n";
      
      const year = options?.year || 2024;
      const week = options?.week;
      
      if (week) {
        prompt += `Week ${week}, ${year} Performance:\n`;
      } else {
        prompt += `${year} Season Performance:\n`;
      }
      
      // Add top performers by position from historical data
      this.addHistoricalPerformanceContext(prompt, week ? 'weekly' : 'season');
      
      prompt += "\n";
    }

    // Add user rankings
    if (allRankings.length > 0) {
      prompt += "USER PROVIDED RANKINGS:\n";
      prompt += "======================\n";
      
      for (const system of allRankings) {
        prompt += `Source: ${system.name}\n`;
        prompt += "--------------------\n";
        for (const ranking of system.rankings.slice(0, 20)) {
          prompt += `${ranking.rank}. ${ranking.playerName} (${ranking.position} - ${ranking.team})\n`;
        }
        prompt += "\n";
      }
    }

    prompt += "\nInstructions: Create consolidated rankings that balance user preferences with historical performance data. ";
    prompt += "Prioritize players with strong historical performance while respecting user ranking systems. ";
    prompt += "Consider recent trends, consistency, and upside potential.\n";

    return prompt;
  }

  private addHistoricalPerformanceContext(prompt: string, type: 'weekly' | 'season'): void {
    if (!this.nflData) return;

    const data = type === 'weekly' ? this.nflData.weekly_stats : this.nflData.aggregated_season_stats;
    
    // Group by position and get top performers
    const positions = ['QB', 'RB', 'WR', 'TE'];
    
    for (const pos of positions) {
      const positionPlayers = data
        .filter(player => player.position === pos)
        .sort((a, b) => (b.fantasy_points_ppr || 0) - (a.fantasy_points_ppr || 0))
        .slice(0, 10);

      if (positionPlayers.length > 0) {
        prompt += `\nTop ${pos}s by Fantasy Points (PPR):\n`;
        positionPlayers.forEach((player, index) => {
          const points = player.fantasy_points_ppr?.toFixed(1) || '0.0';
          const games = type === 'season' ? ` (${player.games || 0} games)` : '';
          prompt += `${index + 1}. ${player.player_name} - ${player.team}: ${points} pts${games}\n`;
        });
      }
    }
  }

  private simulateAIResponse(allRankings: RankingSystem[]): string {
    // This is a simplified simulation. A real AI would provide much more nuanced analysis.
    const allPlayers = allRankings.flatMap(system => system.rankings);
    const uniquePlayers = Array.from(new Set(allPlayers.map(p => p.playerName))).map(name => {
      return allPlayers.find(p => p.playerName === name)!;
    });

    let response = "";
    uniquePlayers.slice(0, 50).forEach((player, index) => {
      response += `${index + 1}. ${player.playerName} - Analysis: Consolidated top player based on average ranking across sources.\n`;
    });

    return response;
  }

  private simulateAIResponseWithHistoricalData(allRankings: RankingSystem[]): string {
    // Enhanced simulation that incorporates historical data
    let response = "";
    let playerRankings: Array<{
      name: string;
      position: string;
      team: string;
      userRank?: number;
      historicalScore: number;
      analysis: string;
    }> = [];

    // Get players from user rankings
    const allPlayers = allRankings.flatMap(system => system.rankings);
    const uniqueUserPlayers = Array.from(new Set(allPlayers.map(p => p.playerName))).map(name => {
      const player = allPlayers.find(p => p.playerName === name)!;
      const avgRank = allPlayers.filter(p => p.playerName === name)
        .reduce((sum, p) => sum + p.rank, 0) / allPlayers.filter(p => p.playerName === name).length;
      
      return {
        name: player.playerName,
        position: player.position,
        team: player.team,
        userRank: avgRank,
        historicalScore: 0,
        analysis: "Based on user rankings"
      };
    });

    // Add top historical performers not in user rankings
    if (this.nflData?.aggregated_season_stats) {
      const topHistoricalPlayers = this.nflData.aggregated_season_stats
        .sort((a, b) => (b.fantasy_points_ppr || 0) - (a.fantasy_points_ppr || 0))
        .slice(0, 100)
        .filter(player => !uniqueUserPlayers.some(up => 
          up.name.toLowerCase().includes(player.player_name?.toLowerCase() || '') ||
          player.player_name?.toLowerCase().includes(up.name.toLowerCase() || '')
        ))
        .slice(0, 25)
        .map(player => ({
          name: player.player_name || 'Unknown',
          position: player.position || 'N/A',
          team: player.team || 'N/A',
          historicalScore: player.fantasy_points_ppr || 0,
          analysis: `Strong historical performer with ${(player.fantasy_points_ppr || 0).toFixed(1)} fantasy points in previous season`
        }));

      playerRankings = [...uniqueUserPlayers, ...topHistoricalPlayers];
    } else {
      playerRankings = uniqueUserPlayers;
    }

    // Sort by combining user rankings and historical performance
    playerRankings.sort((a, b) => {
      // Prioritize users' highly ranked players
      if (a.userRank && b.userRank) {
        return a.userRank - b.userRank;
      }
      if (a.userRank && !b.userRank) {
        return a.userRank < 20 ? -1 : 1; // Top user picks get priority
      }
      if (b.userRank && !a.userRank) {
        return b.userRank < 20 ? 1 : -1;
      }
      // Fall back to historical performance
      return b.historicalScore - a.historicalScore;
    });

    // Generate response
    playerRankings.slice(0, 50).forEach((player, index) => {
      let analysis = player.analysis;
      
      if (player.userRank && player.historicalScore > 0) {
        analysis = `Ranked #${Math.round(player.userRank)} by users with ${player.historicalScore.toFixed(1)} historical fantasy points. Strong consensus pick with proven performance.`;
      } else if (player.userRank) {
        analysis = `Highly rated by users (avg rank #${Math.round(player.userRank)}). Trusted by fantasy experts.`;
      }
      
      response += `${index + 1}. ${player.name} (${player.position} - ${player.team}) - Analysis: ${analysis}\n`;
    });

    return response;
  }

  private parseAIResponse(aiResponse: string): PlayerRanking[] {
    const rankings: PlayerRanking[] = [];
    const lines = aiResponse.split("\n");

    for (const line of lines) {
      // Updated regex to handle the enhanced format with position and team
      const match = line.match(/(\d+)\. (.*?) \((.*?) - (.*?)\) - Analysis: (.*)/);
      if (match) {
        const [, rank, playerName, position, team, analysis] = match;
        rankings.push({
          rank: parseInt(rank),
          playerId: `ai-${playerName.toLowerCase().replace(/\s/g, "-")}`,
          playerName,
          position,
          team,
          notes: analysis,
        });
      } else {
        // Fallback to original format for backward compatibility
        const fallbackMatch = line.match(/(\d+)\. (.*?) - Analysis: (.*)/);
        if (fallbackMatch) {
          const [, rank, playerName, analysis] = fallbackMatch;
          rankings.push({
            rank: parseInt(rank),
            playerId: `ai-${playerName.toLowerCase().replace(/\s/g, "-")}`,
            playerName,
            position: "N/A",
            team: "N/A", 
            notes: analysis,
          });
        }
      }
    }

    return rankings;
  }

  // Helper method to get historical player data for a specific player
  private getHistoricalPlayerData(playerName: string): any {
    if (!this.nflData) return null;

    const normalizedName = playerName.toLowerCase();
    
    // Search in aggregated season stats first
    const seasonData = this.nflData.aggregated_season_stats.find(player => 
      player.player_name?.toLowerCase().includes(normalizedName) ||
      normalizedName.includes(player.player_name?.toLowerCase() || '')
    );

    if (seasonData) return seasonData;

    // Search in weekly stats as fallback
    const weeklyData = this.nflData.weekly_stats.find(player => 
      player.player_name?.toLowerCase().includes(normalizedName) ||
      normalizedName.includes(player.player_name?.toLowerCase() || '')
    );

    return weeklyData;
  }
}