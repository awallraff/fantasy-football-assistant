import { AIRankingsService } from '@/lib/ai-rankings-service'
import type { RankingSystem, PlayerRanking } from '@/lib/rankings-types'

/**
 * Integration tests for AIRankingsService
 * 
 * These tests verify the existing functionality of the AIRankingsService
 * before refactoring to ensure we don't break existing behavior.
 */

describe('AIRankingsService Integration Tests', () => {
  let service: AIRankingsService
  let mockRankingSystems: RankingSystem[]

  beforeEach(() => {
    service = new AIRankingsService()
    
    // Mock ranking systems for testing
    mockRankingSystems = [
      {
        id: 'test-system-1',
        name: 'Test Rankings 1',
        description: 'Test description 1',
        source: 'Test',
        season: '2024',
        scoringFormat: 'ppr',
        positions: ['all'],
        rankings: [
          {
            rank: 1,
            playerId: 'player-1',
            playerName: 'Josh Allen',
            position: 'QB',
            team: 'BUF',
            projectedPoints: 25.5,
            tier: 1,
            notes: 'Top QB'
          },
          {
            rank: 2,
            playerId: 'player-2',
            playerName: 'Christian McCaffrey',
            position: 'RB',
            team: 'SF',
            projectedPoints: 22.8,
            tier: 1,
            notes: 'Elite RB'
          }
        ],
        createdAt: '2024-01-01T00:00:00.000Z',
        updatedAt: '2024-01-01T00:00:00.000Z',
        lastUpdated: '2024-01-01T00:00:00.000Z'
      },
      {
        id: 'test-system-2',
        name: 'Test Rankings 2',
        description: 'Test description 2',
        source: 'Test2',
        season: '2024',
        scoringFormat: 'ppr',
        positions: ['all'],
        rankings: [
          {
            rank: 1,
            playerId: 'player-3',
            playerName: 'Lamar Jackson',
            position: 'QB',
            team: 'BAL',
            projectedPoints: 24.2,
            tier: 1,
            notes: 'Dual-threat QB'
          },
          {
            rank: 2,
            playerId: 'player-2',
            playerName: 'Christian McCaffrey',
            position: 'RB',
            team: 'SF',
            projectedPoints: 23.1,
            tier: 1,
            notes: 'Consistent RB1'
          }
        ],
        createdAt: '2024-01-01T00:00:00.000Z',
        updatedAt: '2024-01-01T00:00:00.000Z',
        lastUpdated: '2024-01-01T00:00:00.000Z'
      }
    ]
  })

  describe('generateAIRankings', () => {
    it('should generate AI rankings for seasonal projections', async () => {
      const result = await service.generateAIRankings(mockRankingSystems, {
        year: 2024,
        useHistoricalData: false // Skip external API calls in tests
      })

      // Verify the basic structure of the returned ranking system
      expect(result).toMatchObject({
        id: 'ai-generated',
        name: expect.stringContaining('AI Season Rankings'),
        description: expect.stringContaining('Season rankings generated by analyzing'),
        source: 'AI',
        season: '2024',
        scoringFormat: 'ppr',
        positions: ['all'],
        createdAt: expect.stringMatching(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/),
        updatedAt: expect.stringMatching(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/),
        lastUpdated: expect.stringMatching(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/)
      })

      // Verify rankings array structure
      expect(result.rankings).toBeInstanceOf(Array)
      expect(result.rankings.length).toBeGreaterThan(0)
      
      // Verify each ranking has required fields
      result.rankings.forEach((ranking: PlayerRanking) => {
        expect(ranking).toMatchObject({
          rank: expect.any(Number),
          playerId: expect.any(String),
          playerName: expect.any(String),
          position: expect.any(String),
          team: expect.any(String)
        })
        
        // Optional fields should be present when data is available
        if (ranking.projectedPoints !== undefined) {
          expect(ranking.projectedPoints).toEqual(expect.any(Number))
        }
        if (ranking.tier !== undefined) {
          expect(ranking.tier).toEqual(expect.any(Number))
        }
        if (ranking.notes !== undefined) {
          expect(ranking.notes).toEqual(expect.any(String))
        }

        // Verify rank is positive
        expect(ranking.rank).toBeGreaterThan(0)
        
        // Verify projected points is reasonable (if present)
        if (ranking.projectedPoints !== undefined) {
          expect(ranking.projectedPoints).toBeGreaterThanOrEqual(0)
        }
        
        // Verify tier is within expected range (if present)
        if (ranking.tier !== undefined) {
          expect(ranking.tier).toBeGreaterThanOrEqual(1)
          expect(ranking.tier).toBeLessThanOrEqual(6)
        }
      })
    })

    it('should generate AI rankings for weekly projections', async () => {
      const result = await service.generateAIRankings(mockRankingSystems, {
        year: 2024,
        week: 5,
        useHistoricalData: false
      })

      // Verify weekly-specific naming
      expect(result.name).toContain('Weekly Rankings')
      expect(result.name).toContain('Week 5')
      expect(result.description).toContain('Weekly rankings')

      // Verify structure is consistent with seasonal
      expect(result.rankings).toBeInstanceOf(Array)
      expect(result.rankings.length).toBeGreaterThan(0)

      // Weekly projections should generally be lower than seasonal (if present)
      result.rankings.forEach((ranking: PlayerRanking) => {
        if (ranking.projectedPoints !== undefined) {
          expect(ranking.projectedPoints).toBeLessThan(500) // Reasonable weekly max
          expect(ranking.projectedPoints).toBeGreaterThanOrEqual(0)
        }
      })
    })

    it('should handle empty ranking systems gracefully', async () => {
      const result = await service.generateAIRankings([], {
        useHistoricalData: false
      })

      expect(result).toMatchObject({
        id: 'ai-generated',
        source: 'AI',
        rankings: expect.any(Array)
      })

      // Should still generate some rankings (simulated AI response)
      expect(result.rankings).toBeInstanceOf(Array)
    })

    it('should use different year when specified', async () => {
      const result = await service.generateAIRankings(mockRankingSystems, {
        year: 2023,
        useHistoricalData: false
      })

      expect(result.season).toBe('2023')
      expect(result.name).toContain('2023')
    })

    it('should default to current year when year not specified', async () => {
      const result = await service.generateAIRankings(mockRankingSystems, {
        useHistoricalData: false
      })

      expect(result.season).toBe('2025') // Default based on current implementation
    })
  })

  describe('generateAIRankings - Edge Cases', () => {
    it('should handle invalid year gracefully', async () => {
      const result = await service.generateAIRankings(mockRankingSystems, {
        year: -1,
        useHistoricalData: false
      })

      expect(result).toBeDefined()
      expect(result.rankings).toBeInstanceOf(Array)
    })

    it('should handle invalid week gracefully', async () => {
      const result = await service.generateAIRankings(mockRankingSystems, {
        year: 2024,
        week: 25, // Invalid week number
        useHistoricalData: false
      })

      expect(result).toBeDefined()
      expect(result.rankings).toBeInstanceOf(Array)
    })

    it('should handle ranking systems with empty rankings arrays', async () => {
      const emptyRankingSystems: RankingSystem[] = [
        {
          ...mockRankingSystems[0],
          rankings: []
        }
      ]

      const result = await service.generateAIRankings(emptyRankingSystems, {
        useHistoricalData: false
      })

      expect(result).toBeDefined()
      expect(result.rankings).toBeInstanceOf(Array)
    })
  })

  describe('generateAIRankings - Ranking Quality', () => {
    it('should generate rankings with proper rank ordering', async () => {
      const result = await service.generateAIRankings(mockRankingSystems, {
        useHistoricalData: false
      })

      const ranks = result.rankings.map(r => r.rank).sort((a, b) => a - b)
      
      // Should have sequential ranking (1, 2, 3, ...)
      for (let i = 0; i < ranks.length; i++) {
        expect(ranks[i]).toBe(i + 1)
      }
    })

    it('should include multiple positions in rankings', async () => {
      const result = await service.generateAIRankings(mockRankingSystems, {
        useHistoricalData: false
      })

      const positions = new Set(result.rankings.map(r => r.position))
      
      // Should have at least one position, ideally multiple from our mock data
      expect(positions.size).toBeGreaterThanOrEqual(1)
      // At minimum should have some recognizable position (not N/A)
      const validPositions = [...positions].filter(pos => pos !== 'N/A' && pos !== 'Unknown')
      expect(validPositions.length).toBeGreaterThan(0)
    })

    it('should generate reasonable projected points ranges', async () => {
      const result = await service.generateAIRankings(mockRankingSystems, {
        useHistoricalData: false
      })

      const definedProjectedPoints = result.rankings
        .map(r => r.projectedPoints)
        .filter(points => points !== undefined) as number[]

      if (definedProjectedPoints.length > 0) {
        const maxPoints = Math.max(...definedProjectedPoints)
        const minPoints = Math.min(...definedProjectedPoints)

        // Seasonal projections should be within reasonable fantasy ranges
        expect(maxPoints).toBeLessThan(1000) // Very high ceiling
        expect(minPoints).toBeGreaterThanOrEqual(0) // Non-negative
        expect(maxPoints).toBeGreaterThan(minPoints) // Some variation
      }
      
      // At minimum, verify we have some rankings
      expect(result.rankings.length).toBeGreaterThan(0)
    })
  })
})
